(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.RSGUI = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Modal = void 0;
    
    var _BaseAnimatableComponent = require("../../scripts/BaseAnimatableComponent");
    
    var Utils = _interopRequireWildcard(require("../../scripts/Utils"));
    
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache = new WeakMap();
    
      _getRequireWildcardCache = function _getRequireWildcardCache() {
        return cache;
      };
    
      return cache;
    }
    
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
    
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return {
          "default": obj
        };
      }
    
      var cache = _getRequireWildcardCache();
    
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
    
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
    
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    
      newObj["default"] = obj;
    
      if (cache) {
        cache.set(obj, newObj);
      }
    
      return newObj;
    }
    
    function _typeof(obj) {
      "@babel/helpers - typeof";
    
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }
    
      return _typeof(obj);
    }
    
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    
    function _createSuper(Derived) {
      return function () {
        var Super = _getPrototypeOf(Derived),
            result;
    
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
    
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
    
        return _possibleConstructorReturn(this, result);
      };
    }
    
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
    
      return _assertThisInitialized(self);
    }
    
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
    
      return self;
    }
    
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
    
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }
    
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }
    
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
    
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
    
      return _setPrototypeOf(o, p);
    }
    
    var RSGModal = /*#__PURE__*/function (_BaseAnimatableCompon) {
      _inherits(RSGModal, _BaseAnimatableCompon);
    
      var _super = _createSuper(RSGModal);
    
      function RSGModal(element) {
        var _this;
    
        var openAutomatically = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    
        _classCallCheck(this, RSGModal);
    
        _this = _super.call(this, element);
        _this.isOpen = false;
        _this.window = Utils.getChildByClass(element, "modal-window");
        _this.scrim = Utils.getChildByClass(element, "modal-scrim");
    
        _this.apply(openAutomatically);
    
        return _this;
      }
    
      _createClass(RSGModal, [{
        key: "apply",
        value: function apply() {
          var openAutomatically = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          this.element.style.display = "none";
          document.addEventListener("keydown", function (e) {
            var keycode = e.keyCode;
    
            if (keycode == 27 && this.isOpen == true) {
              this.close();
            }
          }.bind(this));
          this.scrim.addEventListener("click", function () {
            this.close();
          }.bind(this));
    
          if (openAutomatically) {
            this.open();
          }
        }
      }, {
        key: "open",
        value: function open() {
          this.isOpen = true;
          this.element.classList.add("opening");
          this.element.style.display = "flex";
          this.runAfterNextAnimationFrame(function () {
            this.element.classList.add("active");
          }.bind(this));
          setTimeout(function () {
            this.element.classList.remove("opening");
          }.bind(this), 200);
        }
      }, {
        key: "close",
        value: function close() {
          this.isOpen = false;
          this.element.classList.remove("active");
          setTimeout(function () {
            this.element.style.display = "none";
          }.bind(this), 200);
        }
      }]);
    
      return RSGModal;
    }(_BaseAnimatableComponent.BaseAnimatableComponent);
    
    var Modal = RSGModal;
    exports.Modal = Modal;
    
    },{"../../scripts/BaseAnimatableComponent":6,"../../scripts/Utils":8}],2:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Switch = void 0;
    
    var _BaseComponent2 = require("../../scripts/BaseComponent");
    
    var Utils = _interopRequireWildcard(require("../../scripts/Utils"));
    
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache = new WeakMap();
    
      _getRequireWildcardCache = function _getRequireWildcardCache() {
        return cache;
      };
    
      return cache;
    }
    
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
    
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return {
          "default": obj
        };
      }
    
      var cache = _getRequireWildcardCache();
    
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
    
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
    
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    
      newObj["default"] = obj;
    
      if (cache) {
        cache.set(obj, newObj);
      }
    
      return newObj;
    }
    
    function _typeof(obj) {
      "@babel/helpers - typeof";
    
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }
    
      return _typeof(obj);
    }
    
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    
    function _createSuper(Derived) {
      return function () {
        var Super = _getPrototypeOf(Derived),
            result;
    
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
    
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
    
        return _possibleConstructorReturn(this, result);
      };
    }
    
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
    
      return _assertThisInitialized(self);
    }
    
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
    
      return self;
    }
    
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
    
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }
    
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }
    
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
    
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
    
      return _setPrototypeOf(o, p);
    }
    
    var SwitchValue;
    
    (function (SwitchValue) {
      SwitchValue["on"] = "on";
      SwitchValue["off"] = "off";
    })(SwitchValue || (SwitchValue = {}));
    
    var RSGSwitch = /*#__PURE__*/function (_BaseComponent) {
      _inherits(RSGSwitch, _BaseComponent);
    
      var _super = _createSuper(RSGSwitch);
    
      function RSGSwitch(element) {
        var _this;
    
        _classCallCheck(this, RSGSwitch);
    
        _this = _super.call(this, element);
        _this.checkbox = Utils.getChildByNodeName(element, "input");
        return _this;
      }
      /**
       * The Typescript value of a switch
       * @type SwitchValue
       */
    
    
      _createClass(RSGSwitch, [{
        key: "apply",
        // Gives switch proper functions
        value: function apply() {
          this.checkbox.addEventListener("input", function () {
            if (this.checkbox.checked == true) {
              this.element.classList.add("checked");
            } else {
              this.element.classList.remove("checked");
            }
          });
        }
        /**
         * The value of the switch.
         * @type SwitchValue
         */
    
      }, {
        key: "value",
        get: function get() {
          return SwitchValue[this.checkbox.value];
        }
        /**
         * The value of the switch.
         * @type SwitchValue
         */
        ,
        set: function set(newValue) {
          this.checkbox.value = SwitchValue[newValue];
        }
        /**
         * The value of the switch as a boolean.
         * @type boolean
         */
    
      }, {
        key: "checked",
        get: function get() {
          return this.checkbox.checked;
        }
        /**
         * The value of the switch as a boolean.
         * @type boolean
         */
        ,
        set: function set(newValue) {
          this.checkbox.checked = newValue;
        }
      }], [{
        key: "SwitchValue",
        get: function get() {
          return SwitchValue;
        }
      }]);
    
      return RSGSwitch;
    }(_BaseComponent2.BaseComponent);
    
    var Switch = RSGSwitch;
    exports.Switch = Switch;
    
    },{"../../scripts/BaseComponent":7,"../../scripts/Utils":8}],3:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Tabs = void 0;
    
    var _BaseAnimatableComponent = require("../../scripts/BaseAnimatableComponent");
    
    var Utils = _interopRequireWildcard(require("../../scripts/Utils"));
    
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache = new WeakMap();
    
      _getRequireWildcardCache = function _getRequireWildcardCache() {
        return cache;
      };
    
      return cache;
    }
    
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
    
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return {
          "default": obj
        };
      }
    
      var cache = _getRequireWildcardCache();
    
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
    
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
    
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    
      newObj["default"] = obj;
    
      if (cache) {
        cache.set(obj, newObj);
      }
    
      return newObj;
    }
    
    function _typeof(obj) {
      "@babel/helpers - typeof";
    
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }
    
      return _typeof(obj);
    }
    
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    
    function _createSuper(Derived) {
      return function () {
        var Super = _getPrototypeOf(Derived),
            result;
    
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
    
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
    
        return _possibleConstructorReturn(this, result);
      };
    }
    
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
    
      return _assertThisInitialized(self);
    }
    
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
    
      return self;
    }
    
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
    
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }
    
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }
    
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
    
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
    
      return _setPrototypeOf(o, p);
    }
    
    var TabDirection;
    
    (function (TabDirection) {
      TabDirection["left"] = "LEFT";
      TabDirection["right"] = "RIGHT";
    })(TabDirection || (TabDirection = {}));
    
    var RSGTabs = /*#__PURE__*/function (_BaseAnimatableCompon) {
      _inherits(RSGTabs, _BaseAnimatableCompon);
    
      var _super = _createSuper(RSGTabs);
      /**
       * Creates a tab component.
       * @param element
       */
    
    
      function RSGTabs(element) {
        var _this;
    
        _classCallCheck(this, RSGTabs);
    
        _this = _super.call(this, element);
        _this.content = Utils.getChildByClass(_this.element, "tab-content");
        _this.buttons = Array.from(Utils.getChildByClass(_this.element, "tab-bar", "tab-buttons").children);
        _this.tabs = Array.from(_this.content.children);
        _this.currentButton = Utils.getChildByClass(_this.buttons, "active");
        _this.currentTab = Utils.getChildByClass(_this.tabs, "active");
    
        _this.apply();
    
        return _this;
      } // Gives a smooth transition in case the previous tab has a different size than the next one
      //  (So the content below doesn't jump up after transitioning)
    
    
      _createClass(RSGTabs, [{
        key: "rescaleContainer",
        value: function rescaleContainer() {
          var newHeight = this.currentTab.getBoundingClientRect().height;
          this.content.style.height = newHeight;
        } // Gives buttons proper functions and adds transition to the Tab component.
    
      }, {
        key: "apply",
        value: function apply() {
          var _this2 = this;
    
          var _loop = function _loop(index) {
            var button = _this2.buttons[index];
            button.addEventListener("click", function (event) {
              this.switchToTabAtIndex(index);
            }.bind(_this2));
          };
    
          for (var index = 0; index < this.buttons.length; index++) {
            _loop(index);
          }
        }
      }, {
        key: "switchToTabAtIndex",
        value: function switchToTabAtIndex(index) {
          this.previousButton = this.currentButton;
          this.previousTab = this.currentTab;
          this.currentButton = this.buttons[index];
          this.currentTab = this.tabs[index]; // Transition Indicator
    
          var prevIndicator = this.previousButton.querySelector('.tab-underline');
          var nextIndicator = this.currentButton.querySelector('.tab-underline');
          var nextWidth = prevIndicator.getClientRects()[0].width / nextIndicator.getBoundingClientRect().width;
          var nextLeft = prevIndicator.getClientRects()[0].left - nextIndicator.getBoundingClientRect().left;
          console.log("".concat(nextWidth, " ").concat(nextLeft, ", ").concat(_typeof(nextWidth), " ").concat(_typeof(nextLeft)));
          prevIndicator.parentElement.classList.remove("active");
          nextIndicator.parentElement.classList.add("active");
          var indicatorTransform = "translateX(".concat(nextLeft, "px) scaleX(").concat(nextWidth, ")"); // Transition Tabs
    
          var toDirection = TabDirection.left;
          if (nextLeft < 0) toDirection = TabDirection.right;
          this.previousTab.classList.add("transition");
          this.currentTab.classList.add("transition", "active");
    
          if (toDirection == TabDirection.left) {
            this.previousTab.style.transform = "translateX(100%)";
            this.currentTab.style.transform = "translateX(-100%)";
          } else {
            this.previousTab.style.transform = "translateX(-100%)";
            this.currentTab.style.transform = "translateX(100%)";
          }
    
          if (!this.content.classList.contains("fill-height")) {
            this.rescaleContainer();
          }
    
          nextIndicator.style.transform = indicatorTransform;
          this.runAfterNextAnimationFrame(function () {
            nextIndicator.classList.add("transition");
            nextIndicator.style.transform = "";
            this.currentTab.style.transform = "";
            this.previousButton.classList.remove("active");
            this.currentButton.classList.add("active");
          }.bind(this));
          nextIndicator.addEventListener("transitionend", function () {
            nextIndicator.classList.remove("transition");
            this.previousTab.style.transform = "";
            this.previousTab.classList.remove("active");
            this.currentTab.classList.remove("transition");
          }.bind(this));
        }
      }]);
    
      return RSGTabs;
    }(_BaseAnimatableComponent.BaseAnimatableComponent);
    
    var Tabs = RSGTabs;
    exports.Tabs = Tabs;
    
    },{"../../scripts/BaseAnimatableComponent":6,"../../scripts/Utils":8}],4:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TextField = void 0;
    
    var _BaseComponent2 = require("../../scripts/BaseComponent");
    
    var Utils = _interopRequireWildcard(require("../../scripts/Utils"));
    
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache = new WeakMap();
    
      _getRequireWildcardCache = function _getRequireWildcardCache() {
        return cache;
      };
    
      return cache;
    }
    
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
    
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return {
          "default": obj
        };
      }
    
      var cache = _getRequireWildcardCache();
    
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
    
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
    
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    
      newObj["default"] = obj;
    
      if (cache) {
        cache.set(obj, newObj);
      }
    
      return newObj;
    }
    
    function _typeof(obj) {
      "@babel/helpers - typeof";
    
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }
    
      return _typeof(obj);
    }
    
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    
    function _createSuper(Derived) {
      return function () {
        var Super = _getPrototypeOf(Derived),
            result;
    
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
    
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
    
        return _possibleConstructorReturn(this, result);
      };
    }
    
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
    
      return _assertThisInitialized(self);
    }
    
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
    
      return self;
    }
    
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
    
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }
    
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }
    
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
    
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
    
      return _setPrototypeOf(o, p);
    }
    
    var RSGTextField = /*#__PURE__*/function (_BaseComponent) {
      _inherits(RSGTextField, _BaseComponent);
    
      var _super = _createSuper(RSGTextField);
    
      function RSGTextField(element) {
        var _this;
    
        _classCallCheck(this, RSGTextField);
    
        _this = _super.call(this, element);
        _this.label = Utils.getChildByClass(element, "textfield-label");
        _this.input = Utils.getChildByClass(element, "textfield-input");
    
        _this.apply();
    
        return _this;
      }
    
      _createClass(RSGTextField, [{
        key: "apply",
        value: function apply() {
          if (this.input.value !== "" || this.input.placeholder !== "") this.setFloat(true);
          this.input.addEventListener('focus', function () {
            this.setFloat(true);
            this.label.classList.add("active");
            if (this.element.classList.contains("textfield--expand")) this.element.classList.add("expanded");
          }.bind(this));
          this.input.addEventListener('blur', function () {
            this.label.classList.remove("focus");
            if (this.input.value !== "") return;
            this.setFloat(false);
            this.element.classList.remove("expanded");
          }.bind(this));
          this.input.addEventListener('fireFloat', function () {
            if (this.input.value == "") {
              this.setFloat(false);
            } else {
              this.setFloat(true);
            }
          }.bind(this));
        }
      }, {
        key: "setFloat",
        value: function setFloat(isFloated) {
          if (isFloated) {
            this.label.classList.add("active");
          } else {
            this.label.classList.remove("active");
          }
        }
      }, {
        key: "fireFloat",
        value: function fireFloat() {
          if (this.input.value == "") {
            this.setFloat(false);
          } else {
            this.setFloat(true);
          }
        }
      }, {
        key: "value",
        get: function get() {
          return this.input.value;
        },
        set: function set(newValue) {
          this.input.value = newValue;
          this.input.dispatchEvent(new Event("fireFloat"));
        }
      }]);
    
      return RSGTextField;
    }(_BaseComponent2.BaseComponent);
    
    var TextField = RSGTextField;
    exports.TextField = TextField;
    
    },{"../../scripts/BaseComponent":7,"../../scripts/Utils":8}],5:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _modal = require("./components/modal/modal");
    
    Object.keys(_modal).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _modal[key];
        }
      });
    });
    
    var _switch = require("./components/switch/switch");
    
    Object.keys(_switch).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _switch[key];
        }
      });
    });
    
    var _tabs = require("./components/tabs/tabs");
    
    Object.keys(_tabs).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _tabs[key];
        }
      });
    });
    
    var _textfield = require("./components/textfield/textfield");
    
    Object.keys(_textfield).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _textfield[key];
        }
      });
    });
    
    },{"./components/modal/modal":1,"./components/switch/switch":2,"./components/tabs/tabs":3,"./components/textfield/textfield":4}],6:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BaseAnimatableComponent = void 0;
    
    var _BaseComponent2 = require("./BaseComponent");
    
    function _typeof(obj) {
      "@babel/helpers - typeof";
    
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }
    
      return _typeof(obj);
    }
    
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    
    function _createSuper(Derived) {
      return function () {
        var Super = _getPrototypeOf(Derived),
            result;
    
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
    
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
    
        return _possibleConstructorReturn(this, result);
      };
    }
    
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
    
      return _assertThisInitialized(self);
    }
    
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
    
      return self;
    }
    
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
    
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }
    
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }
    
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
    
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
    
      return _setPrototypeOf(o, p);
    }
    
    var RSGBaseAnimatableComponent = /*#__PURE__*/function (_BaseComponent) {
      _inherits(RSGBaseAnimatableComponent, _BaseComponent);
    
      var _super = _createSuper(RSGBaseAnimatableComponent);
    
      function RSGBaseAnimatableComponent(element) {
        var _this;
    
        _classCallCheck(this, RSGBaseAnimatableComponent);
    
        _this = _super.call(this, element);
        _this.animationFrame = null;
        _this.animationTimer = null;
        return _this;
      }
    
      _createClass(RSGBaseAnimatableComponent, [{
        key: "runAfterNextAnimationFrame",
        value: function runAfterNextAnimationFrame(callback) {
          window.cancelAnimationFrame(this.animationFrame);
          this.animationFrame = window.requestAnimationFrame(function () {
            this.animationFrame = null;
            clearTimeout(this.animationTimer);
            this.animationTimer = setTimeout(callback, 0);
          }.bind(this));
        }
      }]);
    
      return RSGBaseAnimatableComponent;
    }(_BaseComponent2.BaseComponent);
    
    var BaseAnimatableComponent = RSGBaseAnimatableComponent;
    exports.BaseAnimatableComponent = BaseAnimatableComponent;
    
    },{"./BaseComponent":7}],7:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BaseComponent = void 0;
    
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    
    var RSGBaseComponent = /*#__PURE__*/function () {
      function RSGBaseComponent(element) {
        _classCallCheck(this, RSGBaseComponent);
    
        this.element = element;
      }
    
      _createClass(RSGBaseComponent, [{
        key: "remove",
        value: function remove() {
          this.element.remove();
        }
      }]);
    
      return RSGBaseComponent;
    }();
    
    var BaseComponent = RSGBaseComponent;
    exports.BaseComponent = BaseComponent;
    
    },{}],8:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.findChild = findChild;
    exports.getChildByClass = getChildByClass;
    exports.getChildByNodeName = getChildByNodeName;
    
    function findChild(elem, values, callback) {
      var previous = elem;
    
      var _loop = function _loop(index) {
        var value = values[index];
        var children = void 0;
    
        if (previous instanceof Element) {
          children = previous.children;
        } else {
          children = previous;
        }
    
        previous = Array.from(children).find(function (elem) {
          return callback(elem, value);
        });
      };
    
      for (var index = 0; index < values.length; index++) {
        _loop(index);
      }
    
      return previous;
    }
    /**
     * [PREMADE] A deep get method to get an element based on its parents' classes.
     * @param element | array<element>
     * @param ...classes
     * @returns element
     */
    
    
    function getChildByClass(element) {
      for (var _len = arguments.length, classes = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        classes[_key - 1] = arguments[_key];
      }
    
      return findChild(element, classes, function (elem, clas) {
        return elem.classList.contains(clas);
      });
    }
    /**
     * [PREMADE] A deep get method to get an element based on its parents' node names
     * @param element
     * @param ...nodes
     * @returns element
     */
    
    
    function getChildByNodeName(element) {
      for (var _len2 = arguments.length, nodes = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        nodes[_key2 - 1] = arguments[_key2];
      }
    
      return findChild(element, nodes, function (elem, node) {
        return elem.nodeName == node.toUpperCase();
      });
    }
    
    },{}]},{},[5])(5)
    });
    